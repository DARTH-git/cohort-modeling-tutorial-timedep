---
title: 'A Tutorial on Time-Dependent Cohort State-Transition Models in R'
author: 
  - Fernando Alarid-Escudero, PhD^[Division of Public Administration, Center for Research and Teaching in Economics (CIDE), Aguascalientes, AGS, Mexico]
  - Eline Krijkamp, MSc^[Department of Epidemiology, Erasmus University Medical Center, Rotterdam, The Netherlands]
  - Eva A. Enns, PhD^[Division of Health Policy and Management, University of Minnesota School of Public Health, Minneapolis, MN, USA]
  - Alan Yang, MSc^[The Hospital for Sick Children, Toronto]
  - Myriam G.M. Hunink, PhD$^\dagger$^[Center for Health Decision Sciences, Harvard T.H. Chan School of Public Health, Boston, USA]
  - Petros Pechlivanoglou, PhD^[The Hospital for Sick Children, Toronto and University of Toronto, Toronto, Ontario, Canada]
  - Hawre Jalal, MD, PhD^[University of Pittsburgh, Pittsburgh, PA, USA]
date: '`r Sys.Date()`'
documentclass: "article"
output:
  bookdown::pdf_book:
    fig_caption: yes
    keep_tex: yes
always_allow_html: yes
bibliography: WorkingPapers-CohortModelsR.bib
geometry: margin=1in
header-includes:
- \usepackage{amsmath}
- \usepackage{float}
- \usepackage{setspace}\onehalfspacing
# - \usepackage[printwatermark]{xwatermark}
# - \newwatermark[allpages,color=gray!20,angle=45,scale=2,xpos=0,ypos=0]{DRAFT, Do Not Share}
- \renewcommand{\contentsname}{}\vspace{-.5cm} # Removes heading of Contents
keywords: "Markov models, state-transition models, decision models, Tutorial, R"
link-citations: yes
csl: sage-vancouver.csl
site: bookdown::bookdown_site
tags:
- Markov models
- state-transition models
- decision models
- Tutorial
- R
abstract: |
  This tutorial shows how to implement time-dependent cohort state-transition models (cSTMs) to conduct cost-effectiveness analyses (CEA) in R, where transition probabilities and rewards vary by time. We account for two types of time dependency: time since the start of the simulation (simulation-time dependency) and time spent in a health state (state residence dependency). This tutorial is based on an accompanying tutorial that introduces how to implement time-independent cSTMs.We illustrate how to conduct a CEA of multiple strategies based on a time-dependent cSTM using a previously published cSTM, including probabilistic sensitivity analyses. We also demonstrate how to compute various epidemiological outcomes of interest, such as survival probability and prevalence. To illustrate the concepts, we provide both the mathematical notation and the R code to execute the calculations. Finally, similar to the introductory tutorial, we provide a public repository with the R code for broader implementation.
---
```{r, echo = FALSE}
## Journal Abbreviations
# library(RJSONIO)
# if(!file.exists("abbreviations.json")){
# download.file("https://ndownloader.figshare.com/files/5212423","wos_abbrev_table.csv")
#   abbrev <- read.csv("wos_abbrev_table.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
#   abbrev$full <- gsub("\\", "\\\\",abbrev$full, fixed = TRUE)
#   abbrev.list <- list('default' = list('container-title' = abbrev$abbrev.dots))
#   names(abbrev.list$default$`container-title`) = abbrev$full
#   write(toJSON(abbrev.list), "abbreviations.json")
#   rm(abbrev)
#   rm(abbrev.list)
# }
```

```{r setup, include=FALSE}
#install.packages(c("kableExtra", "scales", "dampack"))
library(knitr)
library(kableExtra) # https://haozhu233.github.io/kableExtra/awesome_table_in_html.html
library(dplyr)
library(reshape2)
library(ggplot2)
library(scales) # For dollar signs and commas
library(boot)
library(dampack)
# devtools::install_github("DARTH-git/darthtools")
library(darthtools)
knitr::opts_chunk$set(echo = TRUE)
doc_type <- knitr::opts_knit$get('rmarkdown.pandoc.to')

# Load cSTM and CEA functions
source("../R/Functions_cSTM_time_dep_simulation.R")
source("../R/Functions_cSTM_time_dep_simulation.R")
source("../R/Functions.R")


# Define parameters
cycle_length <- 1  # cycle length equal one year
n_age_init <- 25   # age at baseline
n_age_max  <- 100  # maximum age of follow up
n_cycles <- n_age_max - n_age_init # time horizon, number of cycles
# v_r_mort_by_age <- seq(0.001, 0.01, length.out = 100)
lt_usa_2005 <- read.csv("../data/LifeTable_USA_Mx_2015.csv")
v_r_mort_by_age <- lt_usa_2005 %>% 
  # filter(Age >= age & Age <= n_age_max) %>%
  select(Total) %>%
  as.matrix()

## General setup
v_names_states <- c("H", "S1", "S2", "D") # the 4 health states of the model:
                               # Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n_states <- length(v_names_states) # number of health states 
d_c <- d_e <- 0.03 # equal discount of costs and QALYs by 3%
v_names_str <- c("Standard of care", # store the strategy names
                 "Strategy A", 
                 "Strategy B",
                 "Strategy AB") 
n_str <- length(v_names_str)

## Transition probabilities (per cycle)
p_HS1   <- 0.15  # probability of becoming Sick when Healthy
p_S1H   <- 0.5   # probability of becoming Healthy when Sick
p_S1S2  <- 0.105 # probability of becoming Sicker when Sick
hr_S1   <- 3     # hazard ratio of death in Sick vs Healthy
hr_S2   <- 10    # hazard ratio of death in Sicker vs Healthy 

# Effectiveness of treatment B
hr_S1S2_trtB <- 0.6 # hazard ratio of becoming Sicker when Sick under treatment B

## Transition probability of becoming Sicker when Sick for treatment B
# transform probability to rate
r_S1S2      <- -log(1-p_S1S2)
# apply hazard ratio to rate to obtain transition rate of becoming Sicker when Sick for treatment B
r_S1S2_trtB <- r_S1S2 * hr_S1S2_trtB
# transform rate to probability
p_S1S2_trtB <- 1-exp(-r_S1S2_trtB*cycle_length) # probability to become Sicker when Sick 
                                                # under treatment B conditional on surviving

## Cost and utility inputs 
# State rewards
c_H   <- 2000  # cost of being Healthy for one cycle 
c_S1  <- 4000  # cost of being Sick for one cycle 
c_S2  <- 15000 # cost of being Sicker for one cycle
c_D   <- 0     # cost of being dead for one cycle
c_trtA <- 12000 # cost of treatment A for one cycle 
c_trtB <- 13000 # cost of treatment B for one cycle

u_H   <- 1     # utility of being Healthy for one cycle 
u_S1  <- 0.75  # utility of being Sick for one cycle 
u_S2  <- 0.5   # utility of being Sicker for one cycle
u_D   <- 0     # utility of being dead for one cycle
u_trtA <- 0.95  # utility when being treated for one cycle

# Transition rewards
du_HS1 <- 0.01  # disutility when transitioning from Healthy to Sick
ic_HS1 <- 1000  # increase in cost when transitioning from Healthy to Sick
ic_D   <- 2000  # increase in cost when dying

# PSA parameters
n_sim <- 1000 # Number of PSA samples
```

```{r figure-setup, echo=FALSE, include=FALSE}
## chunk will ensure that:
library(formatR)
# indent = 2: two spaces of indentation.
# tidy=TRUE puts formatR to work to produce a beautiful and standardized layout code.
if(!knitr:::is_html_output())
{
  # options("width"=56)
  knitr::opts_chunk$set(tidy.opts=list(indent = 1.5)) # width.cutoff=56, tidy = TRUE
  knitr::opts_chunk$set(fig.pos = 'H')
}

## chunk will ensure that:
# all the figures generated by the report will be placed in the figs/sub-directory
# all the figures will be 6.5 x 4 inches and centered in the text.
knitr::opts_chunk$set(fig.path="figs/", fig.width=8, fig.height=6, fig.align="center")
```

# Introduction
Cohort state-transition models (cSTMs) are a type of decision model that simulate disease dynamics over time. cSTMs have been used to evaluate different health policy and clinical strategies, such as screening and surveillance programs,[@Suijkerbuijk2018; @Sathianathen2018a] diagnostic procedures,[@Lu2018b] disease management programs,[@Djatche2018] and interventions.[@Pershing2014; @Smith-Spangler2010]. The simplest cSTMs are time-independent (also called "time-homogeneous"), meaning that the transition probabilities and other model parameters remain fixed over the simulated time horizon. In a previous tutorial, we describe the implementation of time-independent cSTMs.[@Alarid-Escudero2021a] However, for many applications, a time-independent cSTM is not sufficient to capture disease dynamics because key parameters do, in reality, vary over time. For example, background mortality changes as a cohort ages, the risk of cancer recurrence might change as a function of time since diagnosis, or the incidence of vector-borne diseases may have temporal or seasonal trends. The costs and utility of residing in a particular health state might also vary over time. For example, cancer-related health care costs might depend on whether a patient is in their first year of remission or their fifth. Similarly, a person's last year of life is often their most expensive in health care spending.

The implementation of more realistic (and thus complex) time-dependent cSTMs is the topic of this tutorial. This tutorial expands the cSTM framework described in the previous tutorial by allowing transition probabilities, costs, and utilities to vary over time and accounting for one-time costs or utilities when the cohort experiences events when transitioning between states. We also demonstrate how to compute various epidemiological measures from cSTMs that may be needed for model calibration or validation.

In this tutorial, we make a conceptual distinction between time-dependency related to the time since the start of the simulation (simulation time-dependency) and the time spent in a health state (state residence time-dependency), as this translates in different implementation approaches. Simulation time-dependency reflects parameters that vary with time and affects the entire cohort in the same way. The most common example of simulation time-dependency is, for a single-age cohort, how age-specific background mortality changes over time as the cohort ages. Since all members of the cohort age at the same rate, this dependency can be implemented by changing the mortality model parameters as the simulation progresses.[@Snowsill2019] For the same reason, in a model simulating a cohort starting from disease diagnosis, any dependence on time since diagnosis can be implemented as a dependence on the time since simulation start. Seasonal or temporal variation in disease incidence can also be reflected through simulation-time dependency, where the risk of developing a disease can be allowed to vary based on the current season or year in the simulation.

State-residence time-dependency captures time-dependence on events that members of the cohort could experience at different times. That is, in a model simulating a healthy cohort as they develop a disease over time, cohort individuals experience disease onset at different times. Thus, parameters that depend on the time since disease onset cannot be implemented based on simulation time; instead, we need to track members of the cohort *from their disease onset time*. This type of time-dependency is implemented by expanding the model state space to include disease states that encode the time since an event. For example, instead of a single "Sick" state, individuals would transition first to the "Sick - cycle 1" state at disease onset, then "Sick - cycle 2" at the next cycle, and so on. In this way, each replicate of the "Sick" state can have different transition probabilities (e.g., mortality, risk of complications, etc.), costs, or utilities. We should note that the state-space expansion approach to time-dependency is the most generalizable implementation approach because one could always expand the entire model state-space for each cycle in the simulated time horizon to capture simulation-time dependence. In this sense, changing parameters with each simulation cycle can be seen as a shortcut. However, in practice, substantial state-space expansion is cumbersome and potentially computationally burdensome. Thus, when time-dependence can be implemented as depending on simulation time, it should be.

This tutorial also expands our example to illustrate the concept and implementation of transition rewards, where one-time costs or utility impacts are applied when individuals transition between certain states. These transition rewards reflect event-driven outcome impacts, such as a higher cost for the first cycle of disease onset due to increased diagnostic and management costs or the increased cost of transition to the dead state incurred from end-of-life interventions or management. While these event-driven impacts could be captured by expanding the model state-space to include an initial disease state or a pre-death, end-of-life state, state-space expansion can be avoided by calculating incurred rewards based on the number of individuals of the cohort making the relevant transition. For implementation, this requires storing not just the cohort trace, which reflects how many individuals are in each state at a given cycle, but also a cohort state-transition array, which records how many individuals are making each possible transition at a given cycle.[@Krijkamp2019]

Finally, this tutorial also illustrates the calculation of more advanced epidemiological outputs beyond the simple cohort trace. These measures include, survival life expectancy, prevalence, and incidence. Some of these calculations leverage the state-transition array implementation that we will introduce, while others are manipulations of the cohort trace. Such epidemiological measures may be of interest for specific analyses but are also important for calibrating and validating the model against real-world data.

In summary, we describe how to implement simulation-time dependent cSTMs and then add state residence dependency to account for both time dependencies, illustrate the implementation of these cSTMs and conduct a cost-effectiveness analysis (CEA) in R, a statistical software with increasing use in health decision sciences.[@Jalal2017b]  Readers can find the most up-to-date model code and code to create the tutorial graphs in the accompanying GitHub repository (https://github.com/DARTH-git/cohort-modeling-tutorial-timedep). We assume that the reader is familiar with the basics of decision modeling and the basics of developing time-independent cSTMs in R, as described in the accompanying tutorial. 

# Simulation-time dependency
Simulation-time dependency can be accounted for by defining the transition probability matrix as a function of time, $P_t$. The elements of $P_t$ are the transition probabilities of moving from state $i$ to state $j$ as a function of time $t$, $p_{[i,j,t]}$, where $\{i,j\} = 1,\ldots, n_S$ and $t = 0,\ldots,n_T$, with $n_S$ being the number of health states of the model and $n_T$ the number of cycles that represent total simulation time. 
$$
  P_t = 
  \begin{bmatrix}
    p_{[1,1,t]} & p_{[1,2,t]} & \cdots & p_{[1,n_S,t]} \\
    p_{[2,1,t]} & p_{[2,2,t]} & \cdots & p_{[2,n_S,t]} \\
    \vdots    & \vdots  & \ddots & \vdots   \\
    p_{[n_S,1,t]} & p_{[n_S,2,t]} & \cdots & p_{[n_S,n_S,t]} \\
  \end{bmatrix}.
$$
Note that all rows of the transition probability matrix in each cycle $t$ must sum to one, $\sum_{j=1}^{n_S}{p_{[i,j,t]}} = 1$ for all $i = 1,\ldots,n_S$ and $t = 0,\ldots, n_T$.

After defining  the transition probability matrix, we need to specify the initial distribution of the cohort at \(t = 0\). These two components will allow us to simulate the transitions of the cohort across health states over time. Therefore, we define \(\mathbf{m}_{0}\) as the vector that captures the distribution of the cohort among the states at \(t = 0\) (i.e., the initial state vector). The state vector at cycle $t+1$ ($\mathbf{m}_{t+1}$) is then calculated as the matrix product of the state vector at cycle $t$, $\mathbf{m}_{t}$, and the transition probability matrix that the cohort faces in cycle $t$, $P_t$, 

\begin{equation}
  (\#eq:time-dep-matrix-mult)
  \mathbf{m}_{t+1} = \mathbf{m}_{t} P_t \qquad\text{ for }\qquad t = 0,\ldots, (n_T - 1).
\end{equation}

Equation \@ref(eq:time-dep-matrix-mult) is iteratively evaluated until $t = n_T$. 

The cohort trace matrix, $M$, is a matrix of dimensions $(n_T+1) \times n_S$ where each row is a state vector $(-\mathbf{m}_{t}-)$, such that

$$
  M = 
  \begin{bmatrix}
    - \mathbf{m}_0 -  \\
    - \mathbf{m}_1 -  \\
     \vdots \\
    - \mathbf{m}_{n_T} -  
  \end{bmatrix}. 
$$
$M$ stores the output of the cSTM, which we can use to compute various epidemiological outcomes, such as prevalence and survival probability over time, and economic outcomes, such as cumulative resource use and costs. 

# Time dependency on state residence
The implementation of state residence dependency is slightly more involved than simulation-time dependency. As described above, dependence on state residence time occurs when transition probabilities or rewards depend on the time spent in a given state. To account for state residence dependency, we expand the number of states with as many transient states as the number of cycles for which state residency is required. These transient states are often referred to as *tunnel* states where the cohort stays for only one cycle and either transition to the next tunnel state or completely exit the tunnel.

In a scenario where  state-residence in one state lasts $n_{\text{tunnels}}$ cycles, this state needs to be expanded into $n_{\text{tunnels}}$ states, and the transition probability matrix also needs to be expanded to incorporate these additional transient states. This will result in a transition probability matrix of dimensions $n_{S_\text{tunnels}} \times n_{S_\text{tunnels}}$, where $n_{S_\text{tunnels}}$ is the total number of health states ($n_{S_\text{tunnels}} = n_S + n_{\text{tunnels}} - 1$). If the transition probabilities are also dependent on simulation time, we add a third dimension such that the dimensions will become \(n_{S_\text{tunnels}} \times n_{S_\text{tunnels}} \times n_T\). As state residence dependency extends in more health states, the total number of health states will increase, causing what has been referred to as "state explosion". Table \@ref(tab:Timedep-cSTM-components-table) describes the core components of time-dependent cSTMs and their suggested R code names. 

Table: (\#tab:Timedep-cSTM-components-table) Core components of time-dependent cSTMs with their R name.

| Element | Description               | R name |   |
|---------|---------------------------|:------:|---|
| $n_S$   | Number of states          | `n_states`|   |
| $\mathbf{m}_0$   | Initial state vector      | `v_s_init` |   |
| $\mathbf{m}_t$   | State vector in cycle $t$ | `v_mt` |   |
| $M$     | Cohort trace matrix       | `m_M` |   |
| $\mathbf{P}$ | Time-dependent transition probability array | `a_P` |   |
| $\mathbf{A}$ | Transition-dynamics array | `a_A` |   |
| $n_{\text{tunnels}}$| Number of tunnel states | `n_tunnel size`|   |
| $n_{S_{\text{tunnels}}}$| Number of states including tunnel states | `n_states_tunnels` |   |
| $\mathbf{m}_{\text{tunnels}_0}$| Initial state vector for the model with tunnel states | `v_s_init_tunnels` |   |

For a more detailed description of these components with their variable types, data structure, and R name, please see the Supplementary Material.

# Case study: Time-dependent Sick-Sicker model

Similar to the introductory tutorial, we will demonstrate how to implement time-dependent cSTMs in R using the 4-state "Sick-Sicker" model[@Alarid-Escudero2021a] to account for time dependency. We will use this cSTM to conduct a CEA of different treatment strategies accounting for transition rewards. The state-transition diagram of the Sick-Sicker model is presented in Figure \@ref(fig:STD-Sick-Sicker). We first adapt the cSTM to account for simulation-time dependency by allowing age-dependent background mortality and then expand it to account for state-residence dependency.


```{r STD-Sick-Sicker, echo=FALSE, fig.cap="State-transition diagram of the Sick-Sicker cohort state-transition model with the name of the health states and possible transitions with their corresponding transition probability names.", fig.pos="H"}
knitr::include_graphics("figs/Sick-Sicker.png") 
```

The model simulates the health care costs and quality-adjusted life-years (QALYs) of a cohort of `r n_age_init`-year-old individuals at risk of developing a hypothetical disease that has two stages: "Sick" and "Sicker".[@Enns2015e] We simulate the cohort of individuals who all start in the "Healthy" state (denoted by "H") over their lifetime, which means that we will simulate the cohort for `r n_cycles` cycles. The total number of cycles is denoted as $n_T$ and defined in R as `n_cycles`. Healthy individuals face age-specific background mortality and those who become ill over time transition to the "Sick" state (denoted by "S1"). Once healthy individuals get sick, they incur a one-time utility decrement of 0.01 (`du_HS1`, a disutility of transitioning from H to S1) and a transition cost of \$`r comma(ic_HS1)` (`ic_HS1`) that reflects the acute impacts of developing the illness. The S1 state is associated with higher mortality, higher health care costs, and lower quality of life than the H state. Once in the S1 state, individuals may recover (returning to the H state), die (move to the D state), or progress further to the "Sicker" state (denoted by "S2"), with further increases in mortality risk and health care costs and reduced quality of life. We assume that it is not possible to distinguish between individuals in S1 and S2. In the state-residence time-dependent model, the risk of progressing from S1  to S2 is a function of the duration of time spent in S1. Individuals in S1 and S2 face an increased hazard of death, compared to healthy individuals, in the form of a hazard ratio (HR) of 3 and 10, respectively, relative to the background age-specific mortality hazard rate. Once simulated individuals die, they transition to the absorbing D state, where they remain, and incur a one-time cost of \$`r comma(ic_D)` (`ic_D`) that reflects the expected acute care preceding death. All transitions between non-death states are assumed to be conditional on surviving each cycle. We simulated the evolution of the cohort in one-year discrete-time cycles.

We use this cSTM to evaluate the cost-effectiveness of four strategies: Strategy A, strategy B, a combination of A and B (strategy AB), and the standard of care (strategy SoC). Strategy A involves administering treatment A to individuals in S1 and S2 but only increases the QoL of individuals in S1 from `r u_S1` (utility without treatment, `u_S1`) to `r u_trtA` (utility with treatment A, `u_trtA`) and costs \$`r comma(c_trtA)` per year (`c_trtA`).[@Krijkamp2018] This strategy does not impact the QoL of individuals in S2, nor does it change the risk of becoming sick or progressing through the sick states. Strategy B uses treatment B to reduce only the rate of Sick individuals progressing to the S2 state with a hazard ratio (HR) of `r hr_S1S2_trtB` (`hr_S1S2_trtB`) and costs  \$`r comma(c_trtB)` per year (`c_trtB`) and does not affect QoL. Strategy AB involves administering both treatments A and B. We discount both costs and QALYs at an annual rate of `r percent(d_c)`. Model parameters  and the corresponding R variable names are presented in Table \@ref(tab:param-table) and follow the notation described in the DARTH coding framework.[@Alarid-Escudero2019e] 

Note that for strategy A, the model has the same structure and identical transition probabilities to SoC. The only difference is the added cost of the treatment for S1 or S2, and QoL increases for S1. After comparing the four strategies in terms of expected QALYs and costs, we calculate the incremental cost per QALY gained between non-dominated strategies.

<!-- Source of table: https://www.tablesgenerator.com/markdown_tables# -->

Table: (\#tab:param-table) Description of parameters, their R variable name, base-case values and distribution.

|           **Parameter**            |  **R name** | **Base-case** |**Distribution**|
|:-----------------------------------|:-----------:|:-------------:|:--------------:|
| Number of cycles ($n_{T}$)         | `n_cycles`  | `r n_cycles` years | constant  |
| Names of health states             | `v_names_states` | H, S1, S2, D  | constant  |
| Annual discount rate for costs     | `d_c`       |  3%           | constant  |
| Annual discount rate for QALYs     | `d_e`       |  3%           | constant  |
| Number of PSA samples ($K$)        | `n_sim`     | 1,000         | constant  |
| Annual transition probabilities conditional on surviving     |             |               |                |
| - Disease onset (H to S1)          | `p_HS1`     |  0.15         | beta(30, 170)  |
| - Recovery (S1 to H)               | `p_S1H`     |  0.5          | beta(60, 60)   |
| - Time-independent disease progression (S1 to S2) | `p_S1S2` |  0.105 | beta(84, 716) |
| - Time-dependent disease progression (S1 to S2) | `v_p_S1S2_tunnels` | | |
|   &nbsp;&nbsp;&nbsp;&nbsp;Weibull parameters |         |               | |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale ($\lambda$) | `p_S1S2_scale` |  0.08 | lognormal(log(0.08), 0.02) |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape ($\gamma$)  | `p_S1S2_shape` |  1.10 | lognormal(log(1.10), 0.05) |
| Annual mortality                   |             |               |                |
| - Age-dependent background mortality rate (H to D)| `v_r_HDage`    |  age-specific |  constant |
| - Hazard ratio of death in S1 vs H | `hr_S1`     |  3.0          | lognormal(log(3.0), 0.01) |
| - Hazard ratio of death in S2 vs H | `hr_S2`     |  10.0         | lognormal(log(10.0), 0.02) |
| Annual costs                       |             |               |                |
| - Healthy individuals              | `c_H`       |  $2,000       | gamma(100.0, 20.0) |
| - Sick individuals in S1           | `c_S1`      |  $4,000       | gamma(177.8, 22.5) |
| - Sick individuals in S2           | `c_S2`      |  $15,000      | gamma(225.0, 66.7) |
| - Dead individuals                 | `c_D`       |  $0           | -              |
| - Cost of treatment A as an additional costs on individuals treated in S1 or S2 | `c_trtA` | $12,000 | gamma(576.0, 20.8) |
| - Cost of treatment B as an additional costs on individuals treated in S1 or S2 | `c_trtB` | $13,000 | gamma(676.0, 19.2) |
| Utility weights                    |             |               |                |
| - Healthy individuals              | `u_H`       |  1.00         | beta(200, 3)   |
| - Sick individuals in S1           | `u_S1`      |  0.75         | beta(130, 45)  |
| - Sick individuals in S2           | `u_S2`      |  0.50         | beta(230, 230) |
| - Dead individuals                 | `u_D`       |  0.00         |constant        |
| Treatment A effectiveness      |             |               |                |
| - Utility for treated individuals in S1 | `u_trtA` |  0.95        | beta(300, 15)  |
| Treatment B effectiveness      |             |               |                |
| - Reduction in rate of disease progression (S1 to S2) as hazard ratio (HR) | `hr_S1S2_trtB` | log(0.6) | lognormal(log(0.6), 0.1) |
| Transition rewards                 |             |               |                |
| - Utility decrement of healthy individuals | `du_HS1`|  0.01     | beta(11,1088)  |
|   when transitioning to S1         |             |               |                |
| - Cost of healthy individuals      | `ic_HS1`    |  $1,000       | gamma(25, 40)   |
|   when transitioning to S1         |             |               |             |
| - Cost of dying when transitioning to D | `ic_D` |  $2,000       | gamma(100, 20)   |

The R code below describes the initialization of the input parameters.

```{r Model-Params, eval=FALSE}
## General setup
cycle_length <- 1 # cycle length equal one year
n_age_init <- 25  # age at baseline
n_age_max  <- 100 # maximum age of follow up
n_cycles <- n_age_max - n_age_init # number of cycles
# The 4 health states of the model:
v_names_states <- c("H",  # Healthy (H)
                    "S1", # Sick (S1)
                    "S2", # Sicker (S2)
                    "D")  # Dead (D)
n_states <- length(v_names_states) # number of health states 
d_e <- 0.03 # discount rate for QALYs of 3% per cycle 
d_c <- 0.03 # discount rate for costs of 3% per cycle 
v_names_str <- c("Standard of care", # store the strategy names
                 "Strategy A", 
                 "Strategy B",
                 "Strategy AB") 

## Transition probabilities (per cycle), hazard ratios and odds ratio (OR)
p_HS1   <- 0.15  # probability of becoming Sick when Healthy
p_S1H   <- 0.5   # probability of becoming Healthy when Sick
p_S1S2  <- 0.105 # probability of becoming Sicker when Sick
hr_S1   <- 3     # hazard ratio of death in Sick vs Healthy
hr_S2   <- 10    # hazard ratio of death in Sicker vs Healthy 

# Effectiveness of treatment B
hr_S1S2_trtB <- 0.6 # hazard ratio of becoming Sicker when Sick under treatment B

## State rewards
## Costs
c_H    <- 2000  # cost of being Healthy for one cycle 
c_S1   <- 4000  # cost of being Sick for one cycle 
c_S2   <- 15000 # cost of being Sicker for one cycle
c_D    <- 0     # cost of being dead for one cycle
c_trtA <- 12000 # cost of receiving treatment A for one cycle
c_trtB <- 13000 # cost of receiving treatment B for one cycle 
# Utilities
u_H    <- 1     # utility of being Healthy for one cycle 
u_S1   <- 0.75  # utility of being Sick for one cycle 
u_S2   <- 0.5   # utility of being Sicker for one cycle
u_D    <- 0     # utility of being dead for one cycle
u_trtA <- 0.95  # utility when receiving treatment A for one cycle

## Transition rewards
du_HS1 <- 0.01  # one-time utility decrement when transitioning from Healthy to Sick
ic_HS1 <- 1000  # one-time cost when transitioning from Healthy to Sick
ic_D   <- 2000  # one-time cost when dying
```

## Simulation-time dependency
To illustrate the implementation of simulation-time dependency in the Sick-Sicker cSTM, we model all-cause mortality as a function of age. We obtain all-cause mortality from life tables in the form of age-specific mortality hazard rates, $\mu(a)$, where $a$ refers to age. For this example, we create a vector `v_r_mort_by_age` with age-specific background mortality hazard rates for 0 to 100 year-olds obtained from the 2015 US life-tables.[@Arias2017] To compute the transition probability from state H to state D, corresponding to cohort's age at each cycle, we transform the rate $\mu(a)$ to a transition probability assuming a constant exponential hazard rate within each year of age
$$
  p_{[H,D,t]} = 1-\exp\left\{{-\mu(a_0 + t)}\right\},
$$ 
where $a_0 =$ `r n_age_init` is the starting age of the cohort. Instead of iterating through the mortality hazard rates, we obtain a vector of background mortality hazard rates for the ages of interest between `r n_age_init` through `r n_age_max` by subsetting \(\mu(a)\) (R variable name `v_r_mort_by_age`) for these ages. We transform the resulting R variable, `v_r_HDage`, to a probability.

```{r}
# Age-specific mortality rate in the Healthy state (background mortality)
v_r_HDage <- v_r_mort_by_age[(n_age_init + 1) + 0:(n_cycles - 1)]
# Transform to age-specific background mortality risk
v_p_HDage  <- 1 - exp(-v_r_HDage) 
```

Because mortality in S1 and S2 are relative to background mortality, adding age dependency to background mortality results in age-dependent mortality in S1 and S2 as well as in H. To generate the age-specific mortality in S1 and S2, we multiply the age-specific background mortality rate, `v_r_HDage`, by the constant hazard ratios `hr_S1` and `hr_S2`, respectively. We then convert the resulting age-specific mortality rates to probabilities.

```{r}
## Age-specific mortality rates in the Sick and Sicker states
v_r_S1Dage <- v_r_HDage * hr_S1 # when Sick
v_r_S2Dage <- v_r_HDage * hr_S2 # when Sicker
## Age-specific probabilities of dying in the Sick and Sicker states
v_p_S1Dage <- 1 - exp(-v_r_S1Dage) # when Sick
v_p_S2Dage <- 1 - exp(-v_r_S2Dage) # when Sicker
```

To incorporate simulation-time dependency into the transition probability matrix, we expand the dimensions of the matrix and create a 3-dimensional transition probability array, $\mathbf{P}$ and `a_P` in R, of dimensions $n_S \times n_S \times n_T$. The first two dimensions of this array correspond to transitions between states and the third dimension to time. The $t$-th element in the third dimension corresponds to the transition probability matrix at cycle $t$. A visual representation of `a_P` is shown in Figure \@ref(fig:Array-Time-Dependent).

```{r Array-Time-Dependent, echo=FALSE, out.width='100%', fig.cap="A 3-dimensional representation of the transition probability array of the Sick-Sicker model with simulation-time dependency.",fig.pos="H"}
knitr::include_graphics("figs/3D-state-transition-array-sick-sicker-without-tunnels.png")
```

First, we initialize `a_P` with a default value of zero for all transition probabilities.

```{r Init-Sick-Sicker-TimeDep-P}
# Initialize the transition probability array
a_P <- array(0, dim = c(n_states, n_states, n_cycles),
              dimnames = list(v_names_states, v_names_states, 0:(n_cycles - 1)))
```

Filling `a_P` with the corresponding transition probabilities of the cohort under the SoC strategy is comparable with filling `m_P` for a time-independent cSTM, accounting for the time dimension, which is represented by the third dimension of the array. However, this requires a slight modification of the code from the time-independent cSTM. The code below illustrates how to assign age-dependent transition probabilities in the third dimension of the array. For constant transitions  over time, we only need to provide one value for the transition probability. R replicates the value of such transitions as many times as the number of cycles ($n_T+1$ times in our example).

```{r Sick-Sicker-TimeDep-P}
### Fill in array
## From H
a_P["H", "H", ]   <- (1 - v_p_HDage) * (1 - p_HS1)
a_P["H", "S1", ]  <- (1 - v_p_HDage) * p_HS1
a_P["H", "D", ]   <- v_p_HDage
## From S1
a_P["S1", "H", ]  <- (1 - v_p_S1Dage) * p_S1H
a_P["S1", "S1", ] <- (1 - v_p_S1Dage) * (1 - (p_S1H + p_S1S2))
a_P["S1", "S2", ] <- (1 - v_p_S1Dage) * p_S1S2
a_P["S1", "D", ]  <- v_p_S1Dage
## From S2
a_P["S2", "S2", ] <- 1 - v_p_S2Dage
a_P["S2", "D", ]  <- v_p_S2Dage
## From D
a_P["D", "D", ]   <- 1
```

As mentioned above, each slice along the third dimension of `a_P` corresponds to a transition probability matrix. For example, the transition matrix for 25-year-olds in the Sick-Sicker model under the SoC strategy can be retrieved using:

```{r Transition-Probability-Array-1}
a_P[, , 1]
```

Similar to the time-independent cSTM, treatment A does not change the transition probabilities. For treatment B, we first initialize the three-dimensional array of transition probabilities, `a_P_trtB` as a copy of `a_P` and update only the probability of remaining in S1 and the transition probability from S1 to S2 (i.e., `p_S1S2` is replaced with `p_S1S2_trtB`).

```{r Sick-Sicker-Time-Dependent-Age-New-Treatment2}
## Initialize transition probability array for treatment B
a_P_trtB <- a_P
## Update only transition probabilities from S1 involving p_S1S2
a_P_trtB["S1", "S1", ] <- (1 - v_p_S1Dage) * (1 - (p_S1H + p_S1S2_trtB))
a_P_trtB["S1", "S2", ] <- (1 - v_p_S1Dage) * p_S1S2_trtB
```

Once we create the transition probability arrays, we check they are valid (i.e., ensuring transition probabilities are between 0 and 1, and transition probabilities from each state sum to 1) using the functions `check_sum_of_transition_array` and `check_transition_probability`, provided in the `darthtools` package (https://github.com/DARTH-git/darthtools).

```{r}
### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(a_P)
check_transition_probability(a_P_trtB)
## Check that all rows sum to 1
check_sum_of_transition_array(a_P,      n_states = n_states, n_cycles = n_cycles)
check_sum_of_transition_array(a_P_trtB, n_states = n_states, n_cycles = n_cycles)
```

In the Sick-Sicker model, the entire cohort starts in the Healthy state. Therefore, we create the $1 \times n_S$ initial state vector `v_s_init` with all of the cohort assigned to the H state:
```{r Sick-Sicker-s0, eval=TRUE, results='hide'}
v_s_init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
v_s_init
#  H S1 S2  D 
#  1  0  0  0
```

We use the variable `v_s_init` to initialize $M$ represented by `m_M` for the cohorts under SoC strategy and strategy A because the transition probabilities are the same under both strategies, and by `m_M_trtB` for the cohorts under strategies B and AB because both transition probabilities under both strategies are affected by treatment B. Note that the initial state vector, `v_s_init`, can be modified to account for the distribution of the cohort across the states at the start of the simulation and might vary by strategy. To simulate the cohort over the $n_T$ cycles for the simulation-time-dependent cSTM, we initialize two new cohort trace matrices `m_M_ad` and `m_M_ad_trtB`.

```{r Init-Sick-Sicker-TimeDependent-Trace}
## Initialize cohort trace for age-dependent (ad) cSTM under SoC
m_M_ad <- matrix(NA, 
                 nrow = (n_cycles + 1), ncol = n_states, 
                 dimnames = list(0:n_cycles, v_names_states))
# Store the initial state vector in the first row of the cohort trace
m_M_ad[1, ] <- v_s_init
## Initialize cohort trace under treatment B
m_M_ad_trtB <- m_M_ad # structure and initial states remain the same.
```

We then use the matrix product to get the state vector at cycle $t$. This equation is similar to the one described for the time-independent model. The only modification required is to index the transition probability arrays `a_P` and `a_P_trtB` by $t$ to obtain the cycle-specific transition probability matrices.

```{r Sick-Sicker-TimeDependent-Solution}
# Iterative solution of age-dependent cSTM
for(t in 1:n_cycles){
  # For SoC
  m_M_ad[t + 1, ] <- m_M_ad[t, ] %*% a_P[, , t]
  # For treatment B
  m_M_ad_trtB[t + 1, ] <- m_M_ad_trtB[t, ] %*% a_P_trtB[, , t]
}
```

A graphical representation of the cohort trace for all cycles of the age-dependent cSTM under strategies SoC and A is shown in Figure \@ref(fig:Sick-Sicker-Trace-AgeDep).

```{r Sick-Sicker-Trace-AgeDep, echo=FALSE, fig.cap='Cohort trace of the age-dependent cSTM under strategies SoC and A.', message=FALSE, warning=FALSE, fig.pos="H"} 
cols <- get_DARTH_cols()
lty <-  c("H" = 1, "S1" = 2, "S2" = 4, "D" = 3)
ggplot(melt(m_M_ad), aes(x = Var1, y = value, 
                         color = Var2, linetype = Var2)) +
  geom_line(size = 1) +
  scale_color_manual(name = "Health state", values = cols) +
  scale_linetype_manual(name = "Health state", values = lty) +
  scale_x_continuous(breaks = number_ticks(8)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom", 
        legend.background = element_rect(fill = NA))
```

## Time dependency on state residence
To add a state-residence dependency to the simulation-time-dependent Sick-Sicker model defined above, we assume the risk of progression from S1 to S2 increases as a function of the time $\tau = 1, \ldots, n_{\text{tunnels}}$ the cohort remains in the S1 state. This increase follows a Weibull hazard function, $h(\tau)$, defined as
$$
  h(\tau) = \gamma \lambda (\lambda \tau)^{\gamma-1},
$$
with a corresponding cumulative hazard, $H(\tau)$,
$$
H(\tau) = (\lambda \tau)^{\gamma},
$$
where $\lambda$ and $\gamma$ are the scale and shape parameters of the Weibull function, respectively.

To derive a transition probability from S1 to S2 as a function as a function of the time the cohort spends in S1, $p_{\left[S1_{\tau},S2, \tau\right]}$, from $H(\tau)$, we use the following equation[@Diaby2014]
\begin{equation}
p_{\left[S1_{\tau},S2, \tau\right]} = 1-\exp{(H(\tau-1) - H(\tau))}
(\#eq:tp-from-H)
\end{equation}

Substituting the Weibull cumulative hazard in Equation \@ref(eq:tp-from-H), the transition probability is $p_{\left[S1_{\tau},S2, \tau\right]}$, is
$$
p_{\left[S1_{\tau},S2, \tau\right]} = 1-\exp{((\lambda (\tau-1))^{\gamma} -  (\lambda \tau)^{\gamma})}.
$$
We assume that state-residence dependency affects the cohort in the S1 state throughout the whole simulation (i.e., $n_{\text{tunnels}}=n_T$) and create a new variable called `n_tunnel_size` with the length of the tunnel equal to `n_cycles`. Thus, there will be `r n_cycles` S1 tunnel states plus `r (n_states-1)` more states (H, S2, D) resulting in a total of $n_{S_{\text{tunnels}}}$ = `r (n_states-1) + n_cycles`.

Figure \@ref(fig:STD-Sick-Sicker-tunnels) shows the Sick-Sicker model's state-transition diagram with state-residence dependency with $n_{\text{tunnels}}$ tunnel states for S1.
 
```{r STD-Sick-Sicker-tunnels, echo=FALSE, out.width='100%', fig.cap="State-transition diagram of the Sick-Sicker model with tunnel states expanding the Sick state ($S1_1, S1_2,...,S1_{n_{\text{tunnels}}}$).", fig.pos="H"}
knitr::include_graphics("figs/Sick-Sicker-with-tunnels.png")
```

To implement state-residence dependency in the Sick-Sicker, we create the vector variables `v_Sick_tunnel` and `v_names_states_tunnels` with the names of the  Sick tunnel states' and all the states of the cSTM, including tunnels, respectively, and use the parameters listed in Table \@ref(tab:Timedep-cSTM-components-table).

```{r}
## Number of tunnels
n_tunnel_size <- n_cycles 
## Vector with cycles for tunnels
v_cycles_tunnel <- 1:n_tunnel_size
## Vector with names for tunnel states of Sick state
v_Sick_tunnel <- paste("S1_", seq(1, n_tunnel_size), "Yr", sep = "")
## Create variables for model with tunnels
v_names_states_tunnels <- c("H", v_Sick_tunnel, "S2", "D") # state names
n_states_tunnels <- length(v_names_states_tunnels)         # number of states
## Initialize first cycle of Markov trace accounting for the tunnels
v_s_init_tunnels <- c(1, rep(0, n_tunnel_size), 0, 0) 
```

Based on the updated parameters, the state-residence-dependent transition probability from Sick to Sicker based on a Weibull function, `v_p_S1S2_tunnels`, is: 
```{r}
# Weibull parameters
p_S1S2_scale <- 0.08 # scale
p_S1S2_shape <- 1.1  # shape
# Weibull function
v_p_S1S2_tunnels <- 1-exp(((v_cycles_tunnel-1)*p_S1S2_scale)^p_S1S2_shape - 
                            (v_cycles_tunnel*p_S1S2_scale)^p_S1S2_shape)
```

To adapt the 3-dimensional transition probability array to incorporate both age and state-residence dependence in the Sick-Sicker model under SoC, we first create an expanded 3-dimensional array accounting for tunnels, `a_P_tunnels`. The dimensions of this array are $n_{S_{\text{tunnels}}} \times n_{S_{\text{tunnels}}} \times n_T$. A visual representation of `a_P_tunnels` of the Sick-Sicker model with tunnel states expanding the Sick state is shown in Figure \@ref(fig:Array-Time-Dependent-Tunnels).

```{r Init-Sick-Sicker-TimeDep-P-tunnels}
# Initialize array
a_P_tunnels <- array(0, dim = c(n_states_tunnels, n_states_tunnels, n_cycles),
                     dimnames = list(v_names_states_tunnels, 
                                     v_names_states_tunnels, 
                                     0:(n_cycles - 1)))
```

```{r Array-Time-Dependent-Tunnels, echo=FALSE, out.width='100%', fig.cap="The 3-dimensional transition probability array of the Sick-Sicker model expanded to account for age-dependence and S1 state-residence using tunnel states.", fig.pos="H"}
knitr::include_graphics("figs/3D-state-transition-array-sick-sicker-tunnels.png")
```

Filling `a_P_tunnels` with the corresponding transition probabilities is similar to how it's done with `a_P` above, with the difference being that we now fill the transition probabilities from all the tunnel states by iterating through all the tunnel states and assigning the corresponding disease progression transition probabilities.

```{r Sick-Sicker-TimeDep-P-tunnels}
### Fill in array
## From H
a_P_tunnels["H", "H", ]              <- (1 - v_p_HDage) * (1 - p_HS1)
a_P_tunnels["H", v_Sick_tunnel[1], ] <- (1 - v_p_HDage) * p_HS1
a_P_tunnels["H", "D", ]              <- v_p_HDage
## From S1
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels[v_Sick_tunnel[i], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ]   <- (1 - v_p_S1Dage) *
                                           (1 - (p_S1H + v_p_S1S2_tunnels[i]))
  a_P_tunnels[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels[i]
  a_P_tunnels[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# Repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) *
                                               (1 - (p_S1H + v_p_S1S2_tunnels[n_tunnel_size]))
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) * 
                                                     v_p_S1S2_tunnels[n_tunnel_size]
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage
### From S2
a_P_tunnels["S2", "S2", ] <- 1 - v_p_S2Dage
a_P_tunnels["S2", "D", ]  <- v_p_S2Dage
# From D
a_P_tunnels["D", "D", ] <- 1
```

Accounting for the effectiveness of treatment B is done similarly to the simulation-time-dependent approach above. We first transform `v_p_S1S2_tunnels` to a vector of rates, `v_r_S1S2_tunnels`, assuming exponentially distributed transitions across the tunnel states, and multiply it by the hazard ratio of treatment B. Then, we transform back to probabilities to produce `v_p_S1S2_tunnels_trtB`, a vector of transition probabilities that account for the duration of S1 state-residence under treatment B.

```{r}
## Transform risk of progression from Sick to Sicker to a rate
# vector of rates of becoming Sicker when Sick
v_r_S1S2_tunnels <- -log(1-v_p_S1S2_tunnels)/cycle_length
# apply hazard ratio to rate to obtain transition rate of becoming Sicker when 
# Sick for treatment B
r_S1S2_tunnels_trtB <- v_r_S1S2_tunnels * hr_S1S2_trtB
# transform rate to probability to become Sicker when Sick under treatment B 
# conditional on surviving
v_p_S1S2_tunnels_trtB <- 1-exp(-r_S1S2_tunnels_trtB*cycle_length) 
```

Then, we initialize the three-dimensional transition probability array for treatment B, `a_P_tunnels_trtB`, based on `a_P_tunnels`. The only difference is that we update the transition probabilities from S1 involving `v_p_S1S2_tunnels` to using `v_p_S1S2_tunnels_trtB` instead.

```{r Sick-Sicker-Time-Dependent-State-Residence-New-Treatment2}
## Initialize transition probability array for treatment B
a_P_tunnels_trtB <- a_P_tunnels
## Update only transition probabilities from S1 involving v_p_S1S2_tunnels
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels_trtB[v_Sick_tunnel[i], "H", ] <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels_trtB[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ] <- (1 - v_p_S1Dage) * 
                                         (1 - (p_S1H + v_p_S1S2_tunnels_trtB[i]))
  a_P_tunnels_trtB[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels_trtB[i]
  a_P_tunnels_trtB[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "H", ] <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) * 
                                               (1 - (p_S1H +v_p_S1S2_tunnels_trtB[n_tunnel_size]))
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) *
                                                           v_p_S1S2_tunnels_trtB[n_tunnel_size]
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage
```

Once we have created both three-dimensional transition probability arrays with tunnels, we check they are valid (i.e., between 0 and 1 and transition probabilities from each state sum to 1).

```{r}
### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(a_P_tunnels)
check_transition_probability(a_P_tunnels_trtB)
## Check that all rows sum to 1
check_sum_of_transition_array(a_P_tunnels,      n_states = n_states_tunnels, 
                              n_cycles = n_cycles)
check_sum_of_transition_array(a_P_tunnels_trtB, n_states = n_states_tunnels, 
                              n_cycles = n_cycles)
```

To simulate the cohort over the $n_T$ cycles for the cSTM accounting for state-residence dependency, we initialize two new cohort trace matrices for the SoC and treatment B, `m_M_tunnels` and `m_M_tunnels_trtB`, respectively.  The dimensions of both matrices are $(n_T+1) \times n_{S_{\text{tunnels}}}$.

```{r Init-Sick-Sicker-TimeDependent-Tunnels-Trace}
# Initialize cohort for state-residence cSTM under SoC
m_M_tunnels <- matrix(0, 
                      nrow = (n_cycles + 1), ncol = n_states_tunnels, 
                      dimnames = list(0:n_cycles, v_names_states_tunnels))
# Store the initial state vector in the first row of the cohort trace
m_M_tunnels[1, ] <- v_s_init_tunnels
## Initialize cohort trace under treatment B
m_M_tunnels_trtB <- m_M_tunnels
```

We then use the matrix product, similar to the simulation-time-dependent cSTM, to generate the full cohort trace.

```{r Sick-Sicker-TimeDependent-Tunnels-Solution}
# Iterative solution of state-residence-dependent cSTM
for(t in 1:n_cycles){
  # For SoC
  m_M_tunnels[t + 1, ] <- m_M_tunnels[t, ] %*% a_P_tunnels[, , t]
  # Under treatment B
  m_M_tunnels_trtB[t + 1,] <- m_M_tunnels_trtB[t, ] %*% a_P_tunnels_trtB[, , t]
}
```

To compute a summarized cohort trace to capture occupancy in the H, S1, S2, D states under SoC, we aggregate over the tunnel states in each cycle(Figure \@ref(fig:Sick-Sicker-Trace-HistDep)).

```{r}
# Create aggregated trace
m_M_tunnels_sum <- cbind(H = m_M_tunnels[, "H"], 
                         S1 = rowSums(m_M_tunnels[, which(v_names_states=="S1"):
                                                    (n_tunnel_size +1)]), 
                         S2 = m_M_tunnels[, "S2"],
                         D = m_M_tunnels[, "D"])
```

```{r Sick-Sicker-Trace-HistDep, echo=FALSE, fig.cap='Cohort trace of the age-dependent cSTM accounting for state-residence dependency under strategies SoC and A.', message=FALSE, warning=FALSE, fig.pos="H"} 
cols <- get_DARTH_cols()
lty <-  c("H" = 1, "S1" = 2, "S2" = 4, "D" = 3)
ggplot(melt(m_M_tunnels_sum), aes(x = Var1, y = value, 
                         color = Var2, linetype = Var2)) +
  geom_line(size = 1) +
  scale_color_manual(name = "Health state", values = cols) +
  scale_linetype_manual(name = "Health state", values = lty) +
  scale_x_continuous(breaks = number_ticks(8)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom", 
        legend.background = element_rect(fill = NA))
```
# Epidemiological and economic measures
cSTMs can be used to generate different epidemiological and economic outputs. In a CEA, the main outcomes are typically the total discounted expected QALYs and total costs accrued by the cohort over the predefined time horizon. However, epidemiological outcomes can be helpful for complementary analyses, such as calibration and validation. Some common epidemiological outcomes include survival, prevalence, incidence, the average number of events, and lifetime risk of events.[@Siebert2012c] We show how to obtain some of these outcomes from the trace and transition probability objects.

## Epidemiological measures
Here we provide the epidemiological definition of some of these outcomes and how they can be generated from a cSTM using the simulation-time-dependent Sick-Sicker cSTM under SoC. In the GitHub repository, we provide the code to generate these outcomes from the state-residence-dependent cSTM.

### Survival probability
The survival probability, $S(t)$, captures the proportion of the cohort remaining alive by cycle $t$. To estimate $S(t)$ from the simulated cohort of the simulation-time-dependent Sick-Sicker model, shown in Figure \@ref(fig:Sick-Sicker-Surv-AgeDep), we sum the proportions of the non-death states for all $n_T$ cycles in `m_M_ad`.

```{r Sick-Sicker-TimeDependent-Surv}
v_S_ad <- rowSums(m_M_ad[, -which(v_names_states == "D")]) # vector with survival curve
``` 

```{r Sick-Sicker-Surv-AgeDep, echo=FALSE, fig.cap='Survival curve of the age-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(data.frame(Cycle = 0:n_cycles, Survival = v_S_ad), 
       aes(x = Cycle, y = Survival)) +
  geom_line(size = 1.3) +
  scale_x_continuous(breaks = number_ticks(8)) + 
  xlab("Cycle") +
  ylab("Proportion alive") +
  theme_bw(base_size = 16) +
  theme()
```

### Life expectancy
Life expectancy (LE) refers to the expected number of time units remaining to be alive.[@Lee2003a] In continuous-time, LE is the area under the entire survival curve.[@Klein2003]

$$
LE = \int_{t=0}^{\infty}{S(t) dt}.
$$

In discrete-time using cSTMs, we often calculate restricted LE over a fixed time horizon (e.g., $n_T$) at which most of the cohort has transitioned to the Dead state and is defined as

$$
  LE = \sum_{t=0}^{n_T}{S(t)}.
$$

```{r Expected-life-years-NoShow, echo=FALSE}
le_ad <- sum(v_S_ad)
```

In the simulation-time-dependent Sick-Sicker model, where we simulated a cohort over  $n_T$= `r n_cycles` cycles, life expectancy `le_ad` is `r round(le_ad, 1)` cycles, which is calculated as

```{r Life-expectancy, eval=FALSE}
le_ad <- sum(v_S_ad) # life expectancy
```

Note that this equation expresses LE in the units of $t$. We use an annual cycle length; thus, the resulting LE will be in years. Analysts can also use other cycle lengths (e.g., monthly or daily), but the LE must be correctly converted to the desired unit if different than the cycle length units.

### Prevalence
Prevalence is defined as the proportion of the population or cohort with a specific condition (or being in a particular health state) among those alive.[@Rothman2008h] To calculate the prevalence of S1 at cycle $t$, $\text{prev}(t)_i$, we compute the ratio between the proportion of the cohort in S1 and the proportion alive at that cycle.[@Keiding1991] The proportion of the cohort alive is given by the survival probability $S(t)$ defined above. The individual prevalence of the S1 and S2 health states and the overall prevalence of sick individuals (i.e., S1 + S2) of the age-dependent Sick-Sicker cSTM at each cycle $t$ is computed as follows and are shown in Figure \@ref(fig:Sick-Sicker-Prev-AgeDep).

```{r Sick-Sicker-TimeDependent-Prevalence}
v_prev_S1   <- m_M_ad[, "S1"] / v_S_ad          # vector with prevalence of Sick
v_prev_S2   <- m_M_ad[, "S2"] / v_S_ad          # vector with prevalence of Sicker
v_prev_S1S2 <- rowSums(m_M_ad[, c("S1", "S2")])/v_S_ad # prevalence of Sick and Sicker
```

```{r Sick-Sicker-Prev-AgeDep, echo=FALSE, fig.cap='Prevalence of sick states in simulation-time-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"} 
df_prev_states <- data.frame(Cycle = 0:n_cycles, 
                  States  = ordered(rep(c("S1", "S2", "S1 + S2"),
                                each = (n_cycles + 1)), 
                                levels = c("S1", "S2", "S1 + S2")), 
                  Prevalence = c(v_prev_S1, 
                                 v_prev_S2, 
                                 v_prev_S1S2))
ggplot(df_prev_states, 
       aes(x = Cycle, y = Prevalence, 
           color = States, linetype = States)) +
  geom_line(size = 1) +
  scale_x_continuous(breaks = number_ticks(8)) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + 
  scale_color_discrete(name = "Health State", l = 50) +
  scale_linetype(name = "Health State") +
  xlab("Cycle") +
  ylab("Prevalence (%)") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom")
```

## Economic measures
In CEA, we can calculate economic outcomes by using either state or transition rewards. A "state reward" refers to a value (e.g., cost, utility) assigned to individuals for remaining in a given health state for one cycle. A "transition reward" refers to the increase or decrease in either costs or utilities of transitioning from one health state to another, which may be associated with a one-time cost or utility impact. In the accompanying introductory tutorial, we describe how to incorporate state rewards in CEA.[@Alarid-Escudero2021a] 

### State rewards
As shown in the introductory tutorial, to add state rewards to the Sick-Sicker model, we first create a vector of utilities and costs for each of the four strategies considered. The vectors of utilities and costs, `v_u_SoC` and `v_c_SoC`, respectively, contain the utilities and costs corresponding to being in each of the four health states under SoC, shown in Table \@ref(tab:param-table).

```{r State-rewards-UC}
# Vector of state utilities under SoC
v_u_SoC <- c(H = u_H, S1 = u_S1, S2 = u_S2, D = u_D)
# Vector of state costs under SoC
v_c_SoC <- c(H = c_H, S1 = c_S1, S2 = c_S2, D = c_D)
```

We account for the benefits and costs of both treatments individually and their combination to create the state-reward vectors under treatments A and B (strategies A and B, respectively) and when applied jointly (strategy AB). Only treatment A affects QoL, so we create a vector of utilities for strategy A, `v_u_strA`, where we substitute the utility of being in S1 under SoC, `u_S1`, with the utility associated with the benefit of treatment A in being in that state, `u_trtA`. Treatment B does not affect QoL, so the vector of utilities for strategy B, `v_u_strB`, is the same as SoC's vector. However, when both treatments A and B are applied jointly (strategy AB), the resulting vector of utilities `v_u_strAB` equals that of strategy A.

```{r State-rewards-U-Tr}
# Vector of state utilities for strategy A
v_u_strA <- c(H = u_H, S1 = u_trtA, S2 = u_S2, D = u_D)
# Vector of state utilities for strategy B
v_u_strB <- v_u_SoC
# Vector of state utilities for strategy AB
v_u_strAB <- v_u_strA
```

Both treatments A and B incur a cost. To create the vector of state costs for strategy A, `v_c_strA`, we add the cost of treatment A, `c_trtA`, to S1 and S2 state costs. Similarly, when constructing the vector of state costs for strategy B, `v_c_strB`, we add the cost of treatment B, `c_trtB`, to S1 and S2 state costs. Finally, for the vector of state costs for strategy AB, `v_c_strAB`, we add both treatment costs to the state costs of S1 and S2.

```{r State-rewards-C-Tr}
# Vector of state costs for strategy A
v_c_strA <- c(H  = c_H, 
              S1 = c_S1 + c_trtA, 
              S2 = c_S2 + c_trtA, 
              D  = c_D)
# Vector of state costs for strategy B
v_c_strB <- c(H  = c_H, 
              S1 = c_S1 + c_trtB, 
              S2 = c_S2 + c_trtB, 
              D  = c_D)
# Vector of state costs for strategy AB
v_c_strAB <- c(H  = c_H, 
               S1 = c_S1 + (c_trtA + c_trtB), 
               S2 = c_S2 + (c_trtA + c_trtB), 
               D  = c_D)
```

<!-- To compute the expected QALYs and costs for the age-dependent Sick-Sicker model under SoC and strategy A, we multiply the cohort trace matrix, `m_M_ad`, times the corresponding strategy-specific state vectors of rewards. Similarly, To compute the expected rewards for strategies B and AB, we multiply the cohort trace matrix accounting for the effectiveness of treatment B, `m_M_ad_trtB`, times their corresponding state vectors of rewards. -->

<!-- ```{r Expected-outcomes-each-cycle} -->
<!-- # Vector of QALYs under SoC -->
<!-- v_qaly_SoC <- m_M_ad %*% v_u_SoC -->
<!-- # Vector of costs under SoC -->
<!-- v_cost_SoC <- m_M_ad %*% v_c_SoC -->
<!-- # Vector of QALYs for strategy A -->
<!-- v_qaly_strA <- m_M_ad %*% v_u_strA -->
<!-- # Vector of costs for strategy A -->
<!-- v_cost_strA <- m_M_ad %*% v_c_strA -->
<!-- # Vector of QALYs for strategy B -->
<!-- v_qaly_strB <- m_M_ad_trtB %*% v_u_strB -->
<!-- # Vector of costs for strategy B -->
<!-- v_cost_strB <- m_M_ad_trtB %*% v_c_strB -->
<!-- # Vector of QALYs for strategy AB -->
<!-- v_qaly_strAB <- m_M_ad_trtB %*% v_u_strAB -->
<!-- # Vector of costs for strategy AB -->
<!-- v_cost_strAB <- m_M_ad_trtB %*% v_c_strAB -->
<!-- ``` -->

### Transition rewards
In the Sick-Sicker model, we previously mentioned that dying (i.e., transitioning to the Dead state) incurs a one-time cost of `r dollar(ic_D)` that reflects the acute care that might be received immediately preceding death. This one-time cost could include emergency services, hospitalization, other healthcare utilization to address the ultimately fatal health complication, or funeral costs. We also have a utility decrement and a cost increment on the transition from H to S1. These changes in utility and costs represent the short-term impact of the acute events of becoming sick, such as hospitalization, stabilization, and so on, whereas the state rewards of S1 described in the previous section reflect the cost and utility of being chronically sick.

Incorporating transition rewards requires keeping track of the proportion of the cohort that transitions between health states in each cycle while capturing what the states of origin and destination are. The cohort trace, $M$, does not capture this information. However, obtaining this information is relatively straightforward in a cSTM and described in detail by Krijkamp et al. (2020).[@Krijkamp2019] Briefly, this approach involves changing the core computation in a traditional cSTM, from $m_t P_t$ to $\text{diag}(m_t) P_t$. This simple change allows us to compute the proportion of the cohort that transitions between the states of origin and destination in cycle $t$. The result is no longer a cohort trace matrix, but rather a three-dimensional array that we refer to as a transition-dynamics array ($\mathbf{A}$) with dimensions \(n_S \times n_S \times [n_T+1]\). The $t-$th slice of $\mathbf{A}$, $A_t$, is a matrix that stores the proportion of the population that transition between states of origin and destination between cycles $t-1$ and $t$. Similarly, we define the transition rewards by the states of origin and destination.

To account for both state and transition rewards, we create a *matrix* of rewards $R_t$ of dimensions $n_S \times n_S$. The off-diagonal entries of $R_t$ store the transition rewards, and the diagonal of $R_t$ stores the state rewards for cycle $t$ and assumes that rewards occur at the beginning of the cycle.[@Krijkamp2019] Finally, we multiply this matrix by $A_t$, the $t$-th slice of $A$, apply discounting, within-cycle correction, and compute the overall reward for each strategy outcome. Below, we illustrate these concepts in R.

To compute $\mathbf{A}$ for the simulation-time-dependent Sick-Sicker model under SoC, we initialize a three-dimensional array `a_A` of dimensions $n_S \times n_S \times [n_T+1]$ and set the diagonal of the first slice to the initial state vector `v_s_init`. Next, we create a three-dimensional array for the cohort under treatment B, `a_A_trtB`, as a copy of the array under SoC.

```{r Init-Transition-Array}
# Initialize transition-dynamics array under SoC
a_A <- array(0,
             dim = c(n_states, n_states, (n_cycles + 1)),
             dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Set first slice to the initial state vector in its diagonal
diag(a_A[, , 1]) <- v_s_init
# Initialize transition-dynamics array under treatment B
a_A_trtB <- a_A
```

We then compute a matrix multiplication between a diagonal matrix of each of the $t$-th rows of the cohort trace matrix under SoC and treatment B, denoted as `diag(m_M_ad[t, ])` and `diag(m_M_ad_trtB[t, ])`, by the $t$-th matrix of the array of transition matrices, `a_P[, , t]` and `a_P_trtB[, , t]`, respectively,  over all $n_T$ cycles.

```{r Compute-Transition-Array}
# Iterative solution to produce the transition-dynamics array
for (t in 1:n_cycles){
  # For SoC
  a_A[, , t + 1] <- diag(m_M_ad[t, ]) %*% a_P[, , t]
  # For treatment B
  a_A_trtB[, , t + 1] <- m_M_ad_trtB[t, ]  * a_P_trtB[, , t]
}
```

To create the arrays of rewards for costs and utilities for the simulation-time-dependent Sick-Sicker cSTM, we create strategy-specific three-dimensional arrays of rewards and fill each of their rows across the third dimension with the vector of state rewards.

```{r Init-Reward-Array}
# Arrays of state and transition rewards
# Utilities under SoC
a_R_u_SoC <- array(matrix(v_u_SoC, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under SoC
a_R_c_SoC <- array(matrix(v_c_SoC, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy A
a_R_u_strA <-  array(matrix(v_u_strA, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy A
a_R_c_strA <- array(matrix(v_c_strA, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy B
a_R_u_strB <-  array(matrix(v_u_strB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy B
a_R_c_strB <- array(matrix(v_c_strB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy AB
a_R_u_strAB <-  array(matrix(v_u_strAB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy AB
a_R_c_strAB <- array(matrix(v_c_strAB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
```

To account for the transition rewards, we either add or subtract them in the corresponding location of the reward matrix representing the transitions of interest. Thus, for example, to account for the disutility of transitioning from H to S1 under strategy A, we subtract the disutility to the entry of the array of rewards corresponding to the transition from H to S1 across all cycles.

```{r Add-DisUtility-Tr}
# Add disutility due to transition from Healthy to Sick
a_R_u_strA["H", "S1", ] <- a_R_u_strA["H", "S1", ] - du_HS1
```

In a similar approach, we add the costs of transitioning from H to S1 and the cost of dying under strategy A.

```{r Add-IncCosts-Tr}
# Add transition cost due to transition from Healthy to Sick
a_R_c_strA["H", "S1", ] <- a_R_c_strA["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strA[-n_states, "D", ] <- a_R_c_strA[-n_states, "D", ] + ic_D
a_R_c_strA[, , 1]
```

Below, we show how to add the transition rewards to the reward matrices under SoC and strategies B and AB.

```{r Add-TransReward-UC}
## SoC
# Add disutility due to transition from H to S1
a_R_u_SoC["H", "S1", ] <- a_R_u_SoC["H", "S1", ] - du_HS1
# Add transition cost due to transition from H to S1
a_R_c_SoC["H", "S1", ] <- a_R_c_SoC["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_SoC[-n_states, "D", ] <- a_R_c_SoC[-n_states, "D", ] + ic_D

## Strategy B
# Add disutility due to transition from Healthy to Sick
a_R_u_strB["H", "S1", ] <- a_R_u_strB["H", "S1", ] - du_HS1
# Add transition cost due to transition from Healthy to Sick
a_R_c_strB["H", "S1", ] <- a_R_c_strB["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strB[-n_states, "D", ] <- a_R_c_strB[-n_states, "D", ] + ic_D

## Strategy AB
# Add disutility due to transition from Healthy to Sick
a_R_u_strAB["H", "S1", ] <- a_R_u_strAB["H", "S1", ] - du_HS1
# Add transition cost due to transition from Healthy to Sick
a_R_c_strAB["H", "S1", ] <- a_R_c_strAB["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strAB[-n_states, "D", ] <- a_R_c_strAB[-n_states, "D", ] + ic_D
```

The state and transition rewards are applied to the model dynamics by element-wise multiplication between $\mathbf{A}$ and $\mathbf{R}$, indicated by the $\odot$ sign, which produces the array of outputs for all $n_T$ cycles, $\mathbf{Y}$. Formally,
\begin{equation}
  \mathbf{Y} = \mathbf{A} \odot \mathbf{R}
  (\#eq:array-outputs)
\end{equation}

To obtain $\mathbf{Y}$ for QALYs and costs for all four strategies, we apply Equation \@ref(eq:array-outputs) by the element-wise multiplication of the transition array `a_A` by the corresponding array of rewards.

```{r Expected-Outcomes-Transitions-Cycle}
# For SoC
a_Y_c_SoC <- a_A * a_R_c_SoC
a_Y_u_SoC <- a_A * a_R_u_SoC
# For Strategy A
a_Y_c_strA <- a_A * a_R_c_strA
a_Y_u_strA <- a_A * a_R_u_strA
# For Strategy B
a_Y_c_strB <- a_A_trtB * a_R_c_strB
a_Y_u_strB <- a_A_trtB * a_R_u_strB
# For Strategy AB
a_Y_c_strAB <- a_A_trtB * a_R_c_strAB
a_Y_u_strAB <- a_A_trtB * a_R_u_strAB
```

The total rewards for each health state at cycle $t$, $\mathbf{y}_t$, is obtained by summing the rewards across all $j = 1,\ldots, n_S$ health states for all $n_T$ cycles.
\begin{equation}
  \mathbf{y}_t = \mathbf{1}^T Y_t = \left[\sum_{i=1}^{n_S}{Y_{[i,1,t]}}, \sum_{i=1}^{n_S}{Y_{[i,2,t]}}, \dots , \sum_{i=1}^{n_S}{Y_{[i,n_S,t]}}\right].
  (\#eq:exp-rewd-trans)
\end{equation}

To obtain the expected costs and QALYs per cycle for each strategy, $\mathbf{y}$, we apply Equation \@ref(eq:exp-rewd-trans) again across all the matrices of the third dimension of $\mathbf{Y}$ for all the outcomes.

```{r Expected-Outcomes-Cycle}
# Vectors of rewards
# QALYs under SoC
v_qaly_SoC <- rowSums(t(colSums(a_Y_u_SoC)))
# Costs under SoC
v_cost_SoC <- rowSums(t(colSums(a_Y_c_SoC)))
# QALYs under Strategy A
v_qaly_strA <- rowSums(t(colSums(a_Y_u_strA)))
# Costs under Strategy A
v_cost_strA <- rowSums(t(colSums(a_Y_c_strA)))
# QALYs under Strategy B
v_qaly_strB <- rowSums(t(colSums(a_Y_u_strB)))
# Costs under Strategy B
v_cost_strB <- rowSums(t(colSums(a_Y_c_strB)))
# QALYs under Strategy AB
v_qaly_strAB <- rowSums(t(colSums(a_Y_u_strAB)))
# Costs under Strategy AB
v_cost_strAB <- rowSums(t(colSums(a_Y_c_strAB)))
```

### Within-cycle correction and discounting future rewards
Following the accompanying introductory cSTM tutorial,[@Alarid-Escudero2021a] here we use Simpson's 1/3rd rule for within-cycle correction (WCC),[@Elbasha2016, @Elbasha2016a] and use exponential discounting for costs and QALYs. In our example, the WCC vector, $\mathbf{wcc}$, is the same for both costs and QALYs; thus, only one vector, `v_wcc`, is required.
```{r within-cycle-vector}
## Vector with cycles
v_cycles <- seq(1, n_cycles+1)
## Generate 2/3 and 4/3 multipliers for even and odd entries, respectively
v_wcc <- ((v_cycles %% 2)==0)*(2/3) + ((v_cycles %% 2)!=0)*(4/3)
## Substitute 1/3 in first and last entries
v_wcc[1] <- v_wcc[n_cycles + 1] <- 1/3
```

The discount vectors, $\mathbf{d}$, for costs and QALYs for the Sick-Sicker model, `v_dwc` and `v_dwe`, respectively, are 

```{r Discount vectors}
# Discount weight for effects
v_dwe <- 1 / ((1 + d_e) ^ (0:(n_cycles)))  
# Discount weight for costs 
v_dwc <- 1 / ((1 + d_c) ^ (0:(n_cycles)))    
```

To account for both discounting and WCC, we incorporate $\mathbf{wcc}$ in equation \@ref(eq:tot-exp-disc-rewd-wcc) using an element-wise multiplication with $\mathbf{d}$, indicated by the $\odot$ symbol, such that 
\begin{equation}
 y = \mathbf{y}^{'} \left(\mathbf{d} \odot \mathbf{wcc}\right).
 (\#eq:tot-exp-disc-rewd-wcc)
\end{equation}

The total expected discounted costs and QALYs under all four strategies accounting for WCC, $y$, is obtained by applying Equation \@ref(eq:tot-exp-disc-rewd-wcc) to the expected outcomes accounting for transition rewards.

```{r}
### For SoC
## QALYs
n_tot_qaly_SoC <- t(v_qaly_SoC) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_SoC <- t(v_cost_SoC) %*% (v_dwc * v_wcc)
### For Strategy A
## QALYs
n_tot_qaly_strA <- t(v_qaly_strA) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strA <- t(v_cost_strA) %*% (v_dwc * v_wcc)
### For Strategy B
## QALYs
n_tot_qaly_strB <- t(v_qaly_strB) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strB <- t(v_cost_strB) %*% (v_dwc * v_wcc)
### For Strategy AB
## QALYs
n_tot_qaly_strAB <- t(v_qaly_strAB) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strAB <- t(v_cost_strAB) %*% (v_dwc * v_wcc)
```

The total expected discounted QALYs and costs for the simulation-time-dependent Sick-Sicker model under the four strategies accounting for WCC are shown in Table \@ref(tab:Expected-outcomes-table). 

```{r Expected-outcomes, echo=FALSE, message=FALSE, warning=FALSE}
m_outcomes <- matrix(c(dollar(c(n_tot_cost_SoC, n_tot_cost_strA, 
                                n_tot_cost_strB, n_tot_cost_strAB)),
                       format(round(c(n_tot_qaly_SoC, n_tot_qaly_strA, 
                               n_tot_qaly_strB, n_tot_qaly_strAB), 3), nsmall = 3)),
                     ncol = 2, nrow = length(v_names_str), 
                     dimnames = list(v_names_str,
                                     c("Costs", "QALYs")))
```

```{r Expected-outcomes-table, echo=FALSE, message=FALSE, warning=FALSE}
kable(m_outcomes, 
      format = ifelse(doc_type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Total expected discounted QALYs and costs per average individual in the cohort of the simulation-time-dependent Sick-Sicker model by strategy accounting for within-cycle correction .", 
      align = c("l", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```

# Incremental cost-effectiveness ratios (ICERs)
To conduct the cost-effectiveness analysis, we follow the coding approach described in the accompanying introductory cSTM tutorial.[@Alarid-Escudero2021a] We combine the total expected discounted costs and QALYs for all four strategies into outcome-specific vectors, `v_cost_str` for costs and `v_qaly_str` for QALYs. We use the R package `dampack` (https://cran.r-project.org/web/packages/dampack/)[@Alarid-Escudero2021] to calculate the incremental costs and effectiveness and the incremental cost-effectiveness ratio (ICER) between non-dominated strategies. The results are returned as the R the data frame `df_cea`.

```{r CEA-analysis}
### Vector of costs
v_cost_str <- c(n_tot_cost_SoC, n_tot_cost_strA, n_tot_cost_strB, n_tot_cost_strAB)
### Vector of effectiveness
v_qaly_str <- c(n_tot_qaly_SoC, n_tot_qaly_strA, n_tot_qaly_strB, n_tot_qaly_strAB)

### Calculate incremental cost-effectiveness ratios (ICERs)
df_cea <- dampack::calculate_icers(cost = v_cost_str, 
                                   effect = v_qaly_str,
                                   strategies = v_names_str)
```

```{r CEA-table, echo=FALSE}
table_cea <- df_cea
## Format column names
colnames(table_cea)[2:6] <- c("Costs ($)", "QALYs", 
                              "Incremental Costs ($)", "Incremental QALYs", 
                              "ICER ($/QALY)") # name the columns
table_cea$`Costs ($)` <- comma(round(table_cea$`Costs ($)`, 0))
table_cea$`Incremental Costs ($)` <- comma(round(table_cea$`Incremental Costs ($)`, 0))
table_cea$QALYs <- round(table_cea$QALYs, 3)
table_cea$`Incremental QALYs` <- round(table_cea$`Incremental QALYs`, 3)
table_cea$`ICER ($/QALY)` <- comma(round(table_cea$`ICER ($/QALY)`, 0))
```

In terms of their costs and effectiveness, SoC is the least costly and effective strategy, followed by Strategy B producing an expected benefit of `r round(table_cea[2, 5], 3)` QALYs per individual for an additional expected cost of \$`r table_cea[2, 4]` with an ICER of \$`r table_cea[2, 6]`/QALY followed by Strategy AB with an ICER \$`r table_cea[3, 6]`/QALY. Strategy A is a dominated strategy. The results of the CEA of the simulation-time-dependent Sick-Sicker model are presented in Table \@ref(tab:table-cea). The non-dominated strategies, SoC, B, and AB, form the cost-effectiveness efficient frontier of the CEA based on the simulation-time-dependent Sick-Sicker model (Figure \@ref(fig:Sick-Sicker-CEA-AgeDep)).
<!-- The total expected QALYs for SoC and strategies A, B and AB are `r round(n_tot_qaly_SoC, 3)`, `r round(n_tot_qaly_strA, 3)`, `r round(n_tot_qaly_strB, 3)` and `r round(n_tot_qaly_strAB, 3)`, respectively. The total expected costs for SoC and strategies A, B and AB are `r dollar(round(n_tot_cost_SoC, 0))`, `r dollar(round(n_tot_cost_strA, 0))`, `r dollar(round(n_tot_cost_strB, 0))` and `r dollar(round(n_tot_cost_strB, 0))`, respectively.  -->
  
```{r table-cea, echo=FALSE, message=FALSE, warning=FALSE}
kable(table_cea, 
      format = ifelse(doc_type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Cost-effectiveness analysis results for the simulation-time-dependent Sick-Sicker model. ND: Non-dominated strategy; D: Dominated strategy.",
      align = c("r", "c", "c", "c", "c", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```

```{r Sick-Sicker-CEA-AgeDep, echo=FALSE, fig.cap='Cost-effectiveness efficient frontier of all four strategies for the simulation-time-dependent Sick-Sicker model.', message=FALSE, warning=FALSE, fig.pos="H"} 
plot(df_cea, label = "all", txtsize = 16) +
  expand_limits(x = c(NA, 21.5)) +
  theme(legend.position = c(0.8, 0.2))
```

# Probabilistic sensitivity analysis
We conducted a probabilistic sensitivity analysis (PSA) to quantify the effect of model parameter uncertainty on cost-effectiveness outcomes.[@Briggs2012] In a PSA, we randomly draw parameter sets from distributions that reflect the current uncertainty in model parameter estimates. The parameters' distributions and their values are described in Table \@ref(tab:param-table) and more detail in the Supplementary Material. We compute model outcomes for each sampled set of parameter values (e.g., total discounted cost and QALYs) for each strategy. In a previously published manuscript, we describe the implementation of these steps in R.[@Alarid-Escudero2019e]
<!-- Briefly, to conduct the PSA, we create three R functions: -->
  
```{r PSA-setup, eval=TRUE, echo=FALSE}
# Number of PSA samples
n_sim <- 1000
# Generate PSA input dataset
df_psa_input <- generate_psa_params(n_sim = n_sim)

# Initialize matrices with PSA output 
# data.frame for costs
df_c <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_c) <- v_names_str
# data.frame for effectiveness
df_e <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_e) <- v_names_str
```

<!-- 1. A function called `generate_psa_params(n_sim, seed)` with arguments `n_sim` and `seed`. The function generates a sample of size `n_sim` for the model parameters from their distributions defined in Table \@ref(tab:param-table). The function also takes a seed number as input, `seed`, which ensures reproducibility of the PSA results. By calling this function, we generate the sample of parameter sets for the PSA, `df_psa_input`, via: `df_psa_input <- generate_psa_params(n_sim = n_sim)`. -->
<!-- 2. A function called `decision_model(l_params_all)` that wraps the R code of the time-independent cSTM described in section [Conceptualizing and implementing time-independent cSTM dynamics](#conceptualizing-and-implementing-time-independent-cSTM-dynamics). This function requires inputting a list of all model parameter values, `l_params_all` and whether the user wants print messages via the `verbose` parameter. -->
<!-- 3. A function called `calculate_ce_out(l_params_all, n_wtp = 100000)` that calculates total discounted costs and QALYs based on the `decision_model` function output. This function also computes the net monetary benefit (NMB) for a given willingness-to-pay threshold, specified by the argument `n_wtp`. -->
<!-- These functions are provided in the Supplementary Material and the accompanying GitHub repository of this manuscript. -->

```{r PSA-run, eval=TRUE, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE}
## Conduct probabilistic sensitivity analysis
# Run Markov model on each parameter set of PSA input dataset
for(i in 1:n_sim){
  l_out_temp <- calculate_ce_out(l_params_all = df_psa_input[i, ])
  df_c[i, ]  <- l_out_temp$Cost  
  df_e[i, ]  <- l_out_temp$Effect
  # # Display simulation progress
  # if(i/(n_sim/100) == round(i/(n_sim/100), 0)) { # display progress every 5%
  #   cat('\r', paste(i/n_sim * 100, "% done", sep = " "))
  # }
}
```

```{r Generate-PSA-object, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# Create PSA object for dampack
l_psa <- make_psa_obj(cost          = df_c, 
                      effectiveness = df_e, 
                      parameters    = df_psa_input, 
                      strategies    = v_names_str)
l_psa$strategies <- v_names_str
colnames(l_psa$effectiveness)<- v_names_str
colnames(l_psa$cost)<- v_names_str

# Vector with willingness-to-pay (WTP) thresholds.
v_wtp <- seq(0, 200000, by = 5000)

## Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF)
ceac_obj <- ceac(wtp = v_wtp, psa = l_psa)
ceac_obj$Strategy <- ordered(ceac_obj$Strategy, v_names_str)

##  Expected Loss Curves (ELCs)
elc_obj <- calc_exp_loss(wtp = v_wtp, psa = l_psa)
```

To conduct the PSA of the CEA using the simulation-time-dependent Sick-Sicker cSTM, we sampled `r comma(n_sim)` parameter sets. For each set, we computed the total discounted costs and QALYs of each simulated strategy. Results from a PSA can be represented in various ways. For example, the joint distribution, 95% confidence ellipse, and the expected values of the total discounted costs and QALYs for each strategy can be plotted in a cost-effectiveness (CE) scatter plot (Figure \@ref(fig:CE-scatter-TimeDep)),[@Briggs2002] where each of the `r comma(4*n_sim)` simulations (i.e., `r comma(n_sim)` combinations of total discounted expected costs and QALYs for each of the four strategies) are plotted as a point in the graph. The CE scatter plot for the CEA using the simulation-time-dependent model shows that strategy AB has the highest expected costs and QALYs. Standard of care has the lowest expected cost and QALYs. Strategy B is more effective and least costly than strategy A. And therefore, strategy A is strongly dominated by strategy B.

```{r CE-scatter-TimeDep, echo=FALSE, fig.cap='Cost-effectiveness scatter plot.', message=FALSE, warning=FALSE, fig.pos="H"} 
# CEAC & CEAF plot
plot(l_psa, txtsize = 16) +
  xlab("Effectiveness (QALYs)") +
  guides(col = guide_legend(nrow = 2)) +
  theme(legend.position = "bottom")
```

In Figure \@ref(fig:CEAC-AgeDep), we present the cost-effectiveness acceptability curves (CEACs) showing the probability that each strategy is cost-effective, and the cost-effectiveness frontier (CEAF), which shows the strategy with the highest expected net monetary benefit (NMB), over a range of willingness-to-pay (WTP) thresholds. The NMB for each strategy is defined as the product of total discounted QALYs and the WTP threshold minus the total discounted costs,[@Stinnett1998b] calculated for each PSA parameter set sample. At WTP thresholds less than `r dollar(summary(ceac_obj)[summary(ceac_obj)[, "cost_eff_strat"]=="Standard of care", 2], accuracy = 1)` per QALY, SoC is the strategy with the highest probability of being cost-effective and the highest expected NMB. Strategy B has the highest probability of being cost-effective and the highest expected NMB for WTP thresholds greater than `r dollar(summary(ceac_obj)[summary(ceac_obj)[, "cost_eff_strat"]=="Standard of care", 2], accuracy = 1)` and smaller than `r dollar(summary(ceac_obj)[summary(ceac_obj)[, "cost_eff_strat"]=="Strategy B", 2][1], accuracy = 1)` per QALY. Strategy AB, has the highest expected NMB for WTP thresholds greater than or equal to `r dollar(summary(ceac_obj)[summary(ceac_obj)[, "cost_eff_strat"]=="Strategy B", 2][1], accuracy = 1)` and is the strategy with the highest probability of being cost-effective.

```{r CEAC-AgeDep, echo=FALSE, fig.cap='Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF).', message=FALSE, warning=FALSE, fig.pos="H"} 
# CEAC & CEAF plot
plot(ceac_obj, txtsize = 16, xlim = c(0, NA), n_x_ticks = 14) +
  theme(legend.position = c(0.8, 0.5))
```

We quantify expected loss from each strategy over a range of WTP thresholds with the expected loss curves (ELCs). (Figure \@ref(fig:ELC-AgeDep)). The expected loss considers both the probability of making the wrong decision and the magnitude of the loss due to this decision, representing the foregone benefits of choosing a suboptimal strategy. The expected loss of the optimal strategy represents the lowest envelope of the ELCs because, given current information, the loss cannot be minimized further. The lower envelope also represents the expected value of perfect information (EVPI), which quantifies the value of eliminating parameter uncertainty. The strategy SoC has the lowest expected loss for WTP thresholds less than `r dollar(max(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Standard of care"), "WTP"]), accuracy = 1)` per QALY, strategy B has the lowest expected loss for WTP threshold greater than or equal to `r dollar(min(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Strategy B"), "WTP"]), accuracy = 1)` and less than `r dollar(min(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Strategy AB"), "WTP"]), accuracy = 1)`. Strategy AB has the lowest expected loss for WTP threshold greater than or equal to `r dollar(min(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Strategy AB"), "WTP"]), accuracy = 1)` per QALY. At a WTP threshold of `r dollar(subset(elc_obj, On_Frontier == TRUE)[which.max(subset(elc_obj, On_Frontier == TRUE)$Expected_Loss), "WTP"], accuracy = 1)` per QALY, the EVPI is highest at `r dollar(subset(elc_obj, On_Frontier == TRUE)[which.max(subset(elc_obj, On_Frontier == TRUE)$Expected_Loss), "Expected_Loss"], accuracy = 1)`. For a more detailed description of these outputs and the R code to generate them, we refer the reader to a previous publication by our group.[@Alarid-Escudero2019]

```{r ELC-AgeDep, echo=FALSE, fig.cap='Expected loss curves (ELCs) and expected value of perfect information (EVPI).', message=FALSE, warning=FALSE, fig.pos="H"} 
# ELC plot
plot(elc_obj, log_y = FALSE, txtsize = 16, xlim = c(0, NA), n_x_ticks = 14,
     col = "full") +
  # geom_point(aes(shape = as.name("Strategy"))) +
  scale_y_continuous("Expected Loss (Thousand $)", 
                     breaks = number_ticks(10),
                     labels = function(x) x/1000) +
  theme(legend.position = c(0.4, 0.7))
```
  
# Discussion
In this tutorial, we provided a conceptualization of time-dependent cSTMs with their mathematical description and a walk-through of their implementation for CEA in R using the Sick-Sicker example. We described two types of time-dependency: dependence on the time since the start of the simulation (simulation-time dependency) or dependence on the time spent in a health state (state-residence dependency). In addition, we illustrated how to generate various epidemiological measures from the model and how to incorporate transition rewards in CEAs.

In our example model, we implement simulation-time dependence by expanding the transition probability matrix into a transition probability array, where the third dimension captures time. However, there are alternative implementations of simulation-time dependence in cSTMs. For example, another approach would be to update the time-varying elements of the transition probability matrix $P_t$ at each time point $t$. That would alleviate the need for the construction of the array `a_P`. Updating the transition matrix at each cycle can reduce computer memory requirements but at the expense of increasing the number of operations in the update of $P_t$ at every cycle. Another approach to account for history dependence is to use a 3-dimensional transition probability matrix with dimensions for the current state, future state, and time in the current state.[@Hawkins2005] However, this multidimensional matrix will have to be expanded by another dimension to incorporate age dependence by replicating the states for as many age groups considered in the model. In this tutorial, we used the third dimension as the cohort's age. We incorporated state-residence time dependency by expanding the corresponding health states on the second dimension of the 3-dimensional array to account for time spent in the current state. This approach's benefit is that we can still use the transition dynamics array to capture all states' transitions for all cycles.

The parameterization of our example model assumes all parameters are known, or at least, the characterization of their uncertainty is known (i.e., we know their distributions). However, to construct a real-world cSTM, modelers must conduct a thorough synthesis of current evidence to determine the appropriate model structure and parameter values. For example, the transition probabilities between non-death health states may be estimated in the literature as conditional on being alive or as competing risks with dying; the estimation assumptions behind parameter values should be compatible with how those parameters are used to implement model dynamics.[@Briggs2012] Similarly, our PSA analysis simplifies reality by assuming that all model parameters are independent of each other. More realistically, parameters are often correlated with each other or have a rank order that should be preserved. In such cases, more complex statistical methods that simulate these correlations or rank orderings are needed.[@Goldhaber-Fiebert2015] Modelers should also take care to correctly specify all model parameters for the cycle length of the model. For example, adjusting an annual mortality rate to a weekly probability requires some probability conversion.[@Hunink2014]

As described in the accompanying tutorial, cSTMs are recommended when the number of states is considered "not too large".[@Siebert2012c] This recommendation arises because as the number of states increases, it becomes more challenging to keep track of their construction. It is possible to build reasonably complex cSTMs in R as long as the size of the transition probability matrix and outputs of interest can be stored in the computer's RAM running the analysis. For example, a typical PC with 8GB of RAM can handle a transition probability array of about 1000 states and 600 time-cycle slices. However, these matrices can grow quickly, and if the required number of states gets too large and difficult to manage its coding, it becomes preferable to use a stochastic (Monte Carlo) version of the state-transition model -- often called individual-based state-transition models (iSTM) or microsimulation models -- rather than a cohort simulation model.[@Siebert2012c]  In an iSTM, the risks and rewards of simulated individuals need not depend only on a current health state; it may also depend on their characteristics and attributes. In addition, modelers can store health state history and other events over time for each individual to determine the risk of new events and corresponding costs and effects. Thus, we recommend thinking about the required model structure before implementing it some model structures might remain the same. An iSTM will also require additional functions to describe the dependency of transition probabilities and rewards on individuals' history. In a previous tutorial, we showed how to construct these functions for an iSTM using the Sick-Sicker example.[@Krijkamp2018]

In summary, this tutorial extends our conceptualization of time-independent cSTMs to allow for time dependency. It provides a step-by-step guide to implement them in R. We hope that health decision scientists and health economists find this tutorial useful for developing their cSTMs in a more flexible, efficient, and open-source manner. Ultimately, our goal is to increase model transparency and reproducibility.

# Acknowledgements
Dr Alarid-Escudero was supported by grants U01-CA199335 and U01-CA253913 from the National Cancer Institute (NCI) as part of the Cancer Intervention and Surveillance Modeling Network (CISNET), and a grant by the Gordon and Betty Moore Foundation. Miss Krijkamp was supported by the Society for Medical Decision Making (SMDM) fellowship through a grant by the Gordon and Betty Moore Foundation (GBMF7853). Dr Enns was supported by a grant from the National Institute of Allergy and Infectious Diseases of the National Institutes of Health under award no. K25AI118476. Dr Hunink receives Royalties from Cambridge University Press for a textbook on Medical Decision Making, reimbursement of expenses from the European Society of Radiology (ESR) for work on the ESR guidelines for imaging referrals, reimbursement of expenses from the European Institute for Biomedical Imaging Research (EIBIR) for membership of the Scientific Advisory Board, and research funding from the American Diabetes Association, the Netherlands Organization for Health Research and Development, the German Innovation Fund, Netherlands Educational Grant ("Studie Voorschot Middelen"), and the Gordon and Betty Moore Foundation. Dr Jalal was supported by a grant from the National Institute on Drug Abuse of the National Institute of Health under award no. K01DA048985. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health. The funding agencies had no role in the design of the study, interpretation of results, or writing of the manuscript. The funding agreement ensured the authors independence in designing the study, interpreting the data, writing, and publishing the report. We also want to thank the anonymous reviewers of *Medical Decision Making* for their valuable suggestions and the students who took our classes where we refined these materials.

# References

